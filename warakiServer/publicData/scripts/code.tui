
scrollView = require("app/common/scrollView.tui")
button = require("app/common/button.tui")

playlistsCachePath = file.getSavePath("files/musicLibrary.tuib")
songsCachePath = file.getSavePath("songs/")

file.createDirectoriesIfNeededForDirPath(songsCachePath)

print("songsCachePath:", songsCachePath)

disableCache = false #when true, will ignore the cached playlists, and only download from server
resetCache = false
waitingForDownload = false
hasStartedCache = false
allSongsSuccessfullyCached = false

paused = true

songsToDownloadArray = {}
songsInfosByID = {}

getSongCallback = function(result, hostID)
{
    .waitingForDownload = false
    print("site code got result with status:", result.status, " message:", result.message, " hostID:", hostID)
    if(!result or result.status != "ok")
    {
        print("bad result")
    }
    else if(result.songID and result.fileData and result.fileName)
    {
        print("cache song downloaded: ", result.fileName)#string.length(result))

        songInfo = songsInfosByID[result.songID]
        thisSongCachePath = songsCachePath + songInfo.localPath
        file.createDirectoriesIfNeededForFilePath(thisSongCachePath)
        file.saveData(thisSongCachePath, result.fileData)

            #todo maybe
            #audio.queueSongs(queue)
            #statusSubtitleTextView.text = ""
            ##currentlyPlayingTitleTextView.text = firstItem.fileName
            #.paused = false
            #updatePauseButton()
    }
    else
    {
        print("site code warning: unhandled result.")
        defaultSiteContent.hidden = false
        pageTitle.text = "unhandled result"
        pageBody.text = ""
    }
}


downloadToCache = function(downloadSongIndex)
{
    songCount = table.count(songsToDownloadArray)
    if(downloadSongIndex >= songCount)
    {
        print("all files cached.")
        .allSongsSuccessfullyCached = true
        statusSubtitleTextView.text = "Sync complete"
        return
    }

    songID = songsToDownloadArray[downloadSongIndex]
    songInfo = songsInfosByID[songID]
    
    thisSongCachePath = songsCachePath + songInfo.localPath

    #print("songInfo:", songInfo)
    #print("thisSongCachePath:", thisSongCachePath)


    if(resetCache or !file.fileExists(thisSongCachePath) or file.fileSize(thisSongCachePath) == 0)
    {
        print("downloading song:", songInfo.fileName)
        statusSubtitleTextView.text = "Downloading: " + songInfo.fileName
        #client.downloadFromServer("song", songID, songDownloaded)
        .waitingForDownload = true
        katipo.get("songs/" + songID, getSongCallback)
    }
    else
    {
        print("file exists:", songInfo.fileName)
        statusSubtitleTextView.text = "Syncing"
        #downloadToCache(downloadSongIndex + 1)
    }
}

cacheDownloadIndex = 0

mainLoopFunction = function(dt)
{
    if(!hasStartedCache)
    {
        print("starting cache update:", playlists)
        .hasStartedCache = true
        for(playlist in playlists)
        {
            songs = playlist.songs
            for(song in songs)
            {
                table.insert(songsToDownloadArray, song.songID)
                songsInfosByID[song.songID] = song
            }
        }
    }

    if(hasStartedCache and !waitingForDownload and !allSongsSuccessfullyCached)
    {
        downloadToCache(cacheDownloadIndex)
        cacheDownloadIndex++
    }
}
mainLoopTimer = katipo.addUpdateFunction(mainLoopFunction)

songIndex = 0
currentlyPlayingTitleTextView = scene.getView("currentlyPlayingTitle")
statusSubtitleTextView = scene.getView("statusSubtitle")

settingsButton = scene.getView("settingsButton")
backButton = scene.getView("backButton")
playPauseButton = scene.getView("playPauseButton")
nextButton = scene.getView("nextButton")

playlistsHeader = scene.getView("playlistsHeader")
settingsHeader = scene.getView("settingsHeader")

settingsContent = scene.getView("settingsContent")

settingsClick = function()
{
    playlistsHeader.hidden = true
    settingsHeader.hidden = false
    playlistContentView.hidden = true
    settingsContent.hidden = false
}
button.create(settingsButton, -0.1, settingsClick)


backClick = function()
{
    playlistsHeader.hidden = false
    settingsHeader.hidden = true
    playlistContentView.hidden = false
    settingsContent.hidden = true
}
button.create(backButton, -0.1, backClick)

updatePauseButton = function()
{
    if(paused)
    {
        playPauseButton.path = "img/play.png"
    }
    else
    {
        playPauseButton.path = "img/pause.png"
    }
}

playPauseButtonClick = function()
{
    .paused = !paused
    if(paused)
    {
        audio.stop()
    }
    else
    {
        audio.play()
    }
    updatePauseButton()
}

button.create(playPauseButton, -0.1, playPauseButtonClick)

nextButtonClick = function()
{
    audio.next()
}

button.create(nextButton, -0.1, nextButtonClick)


addButtonView = scene.getView("addButton")
button.create(addButtonView, 0.0)

loadFirstSongAndStartQueue = function()
{
    print("loadFirstSongAndStartQueue")
    queue = {
    }

    currentPlaylist = playlists[currentPlaylistIndex]
    for(songInfo in currentPlaylist.songs)
    {
        thisSongCachePath = songsCachePath + songInfo.localPath
        table.insert(queue, thisSongCachePath)
    }

    firstItem = currentPlaylist.songs[0]
    print("firstItem:", firstItem)
    firstSongCachePath = songsCachePath + firstItem.localPath
    if(!file.fileExists(firstSongCachePath))
    {
        print("Need to download:", firstSongCachePath)
        statusSubtitleTextView.text = "Downloading: " + firstItem.fileName

        audio.stop()

        innerCallback = function(result, hostID) {
            getSongCallback(result, hostID)
            if(paused)
            {
                audio.queueSongs(queue)
                .paused = false
                updatePauseButton()
            }
        }

        katipo.get("songs/" + firstItem.songID, innerCallback)

    }
    else
    {
        audio.queueSongs(queue)
        .paused = false
        updatePauseButton()
    }
}

startCurrentPlaylist = function()
{
    currentPlaylist = playlists[currentPlaylistIndex]
    table.shuffle(currentPlaylist.songs)
    loadFirstSongAndStartQueue()
}

audio.playingSongChanged = function(title, artist, duration)
{
    print("got song changed:", title, " artist:", artist)
    currentlyPlayingTitleTextView.text = title
    if(!hasConnection)
    {
        statusSubtitleTextView.text = artist
    }
}


audio.playingSongPausedChanged = function(newPaused)
{
    .paused = newPaused
    updatePauseButton()
}

loadPlaylists = function(playlists_)
{
    .playlists = playlists_
    playlistCount = table.count(playlists)
    print("got ", playlistCount, " playlists")

    if(table.count(playlists) > 0)
    {
        .playlistContentView = scene.getView("playlistContent")
        playlistContentView = .playlistContentView #tui bug ?

        if(playlistScrollView)
        {
            playlistContentView.removeView(playlistScrollView)
        }

        .playlistScrollView = scrollView.create(playlistContentView)
        playlistScrollView = .playlistScrollView
        viewTable = scene.playlistItemPlayMode #tui bug ?

        for(i,playlist in playlists)
        {
            itemView = playlistScrollView.addView(viewTable)
            titleTextView = itemView.getView("playlistItemTitle")
            titleTextView.text = playlist.title
            //itemView.pos.y -= i * viewTable.size.y

            dotDotDotButton = itemView.getView("dotDotDotButton")
            button.create(dotDotDotButton, 0.2 * i)


            itemView.click = function()
            {
                #print("i:", i)
                .currentPlaylistIndex = i
                #print("currentPlaylistIndex:", currentPlaylistIndex)
                #print("itemView.click parent:", ...)
                startCurrentPlaylist()
            }

            #shuffleButton = itemView.getView("shuffleButton")
            #button.create(shuffleButton, 0.55 * i)

            if(i % 2 == 0)
            {
                itemView.color = itemView.color * 0.5
                itemView.color.w = 0.1
            }

            scrollView.insertRow(playlistScrollView, itemView)
        }
    }
}

playlists = file.loadBinary(playlistsCachePath)
#print("playlists:", playlists)
loadPlaylists(playlists)