# warakiServer/clientSite/scripts/code.tui
# this code is downloaded by the client when they first connect and is run on the client browser. It is the entirety of the waraki client "app"
# It handles the user interface and all client interactions, as well as requesting music from the host

scrollView = require("app/common/scrollView.tui")
button = require("app/common/button.tui")


retryDelay = 60.0 #attempts to download again every retryDelay seconds on failure

playlistsPath = file.getSavePath("files/playlists.tuib")
directoryTreePath = file.getSavePath("files/directoryTree.tuib")
songsCachePath = file.getSavePath("songs/")

file.createDirectoriesIfNeededForDirPath(songsCachePath)

print("songsCachePath:", songsCachePath)

waitingForDownload = false
hasStartedCache = false
allSongsSuccessfullyCached = false

paused = true

songsToDownloadArray = {}
songsInfosByID = {}

playlistContentView = false #create empty var
playlistScrollView = false

retryingAfterFailedToDownload = false
retryTimer = 0
retryCounter = 0

getSongCallback = function(result, hostID)
{
    .waitingForDownload = false
    print("site code got result with status:", result.status, " message:", result.message, " hostID:", hostID)
    if(!result or result.status != "ok")
    {
        if(result and result.message == "not connected")
        {
            .retryingAfterFailedToDownload = true
            .retryTimer = retryDelay
            print("failed to download. trying again in ", retryDelay, " seconds")
            statusSubtitleTextView.text = "Not connected"
        }
        else
        {
            print("failed to download. skipping file.") 
            cacheDownloadIndex++
        }
    }
    else if(result.songID and result.fileData and result.fileName)
    {
        print("cache song downloaded: ", result.fileName)

        songInfo = songsInfosByID[result.songID]
        thisSongCachePath = songsCachePath + songInfo.localPath
        file.createDirectoriesIfNeededForFilePath(thisSongCachePath)
        file.saveData(thisSongCachePath, result.fileData)
        cacheDownloadIndex++
    }
    else
    {
        error("unhandled result.")
        #defaultSiteContent.hidden = false
        #pageTitle.text = "unhandled result"
        #pageBody.text = ""
    }
}

downloadToCache = function(downloadSongIndex)
{
    songCount = table.count(songsToDownloadArray)
    if(downloadSongIndex >= songCount)
    {
        print("all files cached.")
        .allSongsSuccessfullyCached = true
        statusSubtitleTextView.text = "Sync complete"
        return
    }

    songID = songsToDownloadArray[downloadSongIndex]
    songInfo = songsInfosByID[songID]
    
    thisSongCachePath = songsCachePath + songInfo.localPath

    #print("songInfo:", songInfo)
    #print("thisSongCachePath:", thisSongCachePath)

    if(!file.fileExists(thisSongCachePath) or file.fileSize(thisSongCachePath) == 0) #todo != expectedSize
    {
        print("downloading song:", songInfo.fileName)
        statusSubtitleTextView.text = "Downloading: " + songInfo.fileName
        .waitingForDownload = true
        katipo.get("songs/" + songID, getSongCallback)
    }
    else
    {
        //print("file exists:", songInfo.fileName)
        statusSubtitleTextView.text = "Ready"
        cacheDownloadIndex++
        #downloadToCache(downloadSongIndex + 1)
    }
}

cacheDownloadIndex = 0

katipo.update = function(dt) #called every tick
{
    if(!hasStartedCache)
    {
        .hasStartedCache = true
        for(playlist in playlists)
        {
            songs = playlist.songs
            for(song in songs)
            {
                table.insert(songsToDownloadArray, song.songID)
                songsInfosByID[song.songID] = song
            }
        }
    }

    if(hasStartedCache and !waitingForDownload and !allSongsSuccessfullyCached)
    {
        if(retryingAfterFailedToDownload)
        {
            .retryTimer = retryTimer - dt
            if(retryTimer <= 0)
            {
                .retryingAfterFailedToDownload = false
            }
        }
        else
        {
            downloadToCache(cacheDownloadIndex)
        }
    }
}

songIndex = 0
currentlyPlayingTitleTextView = scene.getView("currentlyPlayingTitle")
statusSubtitleTextView = scene.getView("statusSubtitle")

settingsButton = scene.getView("settingsButton")
backButton = scene.getView("backButton")
playPauseButton = scene.getView("playPauseButton")
nextButton = scene.getView("nextButton")

playlistsHeader = scene.getView("playlistsHeader")
settingsHeader = scene.getView("settingsHeader")

settingsContent = scene.getView("settingsContent")

settingsClick = function()
{
    playlistsHeader.hidden = true
    settingsHeader.hidden = false
    playlistContentView.hidden = true
    settingsContent.hidden = false
}
button.create(settingsButton, -0.1, settingsClick)


backClick = function()
{
    playlistsHeader.hidden = false
    settingsHeader.hidden = true
    playlistContentView.hidden = false
    settingsContent.hidden = true
}
button.create(backButton, -0.1, backClick)

updatePauseButton = function()
{
    if(paused)
    {
        playPauseButton.path = "img/play.png"
    }
    else
    {
        playPauseButton.path = "img/pause.png"
    }
}

playPauseButtonClick = function()
{
    .paused = !paused
    paused = .paused #tui bug
    if(paused)
    {
        #print("pause stopping audio")
        audio.stop()
    }
    else
    {
        #print("pause starting audio")
        audio.play()
    }
    updatePauseButton()
}

button.create(playPauseButton, -0.1, playPauseButtonClick)

nextButtonClick = function()
{
    audio.next()
}

button.create(nextButton, -0.1, nextButtonClick)


addButtonView = scene.getView("addButton")
button.create(addButtonView, 0.0)

loadFirstSongAndStartQueue = function()
{
    print("loadFirstSongAndStartQueue")
    queue = {
    }

    currentPlaylist = playlists[currentPlaylistIndex]
    for(songInfo in currentPlaylist.songs)
    {
        thisSongCachePath = songsCachePath + songInfo.localPath
        table.insert(queue, thisSongCachePath)
    }

    firstItem = currentPlaylist.songs[0]
    print("firstItem:", firstItem)
    firstSongCachePath = songsCachePath + firstItem.localPath
    if(!file.fileExists(firstSongCachePath))
    {
        print("Need to download:", firstSongCachePath)
        statusSubtitleTextView.text = "Downloading: " + firstItem.fileName

        audio.stop()

        innerCallback = function(result, hostID) {
            getSongCallback(result, hostID)
            if(paused)
            {
                audio.queueSongs(queue)
                .paused = false
                updatePauseButton()
            }
        }

        katipo.get("songs/" + firstItem.songID, innerCallback)

    }
    else
    {
        audio.queueSongs(queue)
        .paused = false
        updatePauseButton()
    }
}

startCurrentPlaylist = function()
{
    currentPlaylist = playlists[currentPlaylistIndex]
    table.shuffle(currentPlaylist.songs)
    loadFirstSongAndStartQueue()
}

audio.playingSongChanged = function(title, artist, duration)
{
    print("got song changed:", title, " artist:", artist)
    currentlyPlayingTitleTextView.text = title
    statusSubtitleTextView.text = artist
}


audio.playingSongPausedChanged = function(newPaused)
{
    .paused = newPaused
    updatePauseButton()
}

loadPlaylists = function(playlists_)
{
    .playlists = playlists_
    playlistCount = table.count(playlists)
    print("got ", playlistCount, " playlists")

    if(table.count(playlists) > 0)
    {
        .playlistContentView = scene.getView("playlistContent")
        playlistContentView = .playlistContentView #tui bug maybe
        print("playlistContentView:", playlistContentView)
        .playlistScrollView = scrollView.create(playlistContentView)
        playlistScrollView = .playlistScrollView #tui bug  maybe

        viewTable = scene.playlistItemPlayMode

        for(i,playlist in playlists)
        {
            itemView = playlistScrollView.addView(viewTable)
            titleTextView = itemView.getView("playlistItemTitle")
            titleTextView.text = playlist.title
            //itemView.pos.y -= i * viewTable.size.y

            dotDotDotButton = itemView.getView("dotDotDotButton")
            button.create(dotDotDotButton, 0.2 * i)


            itemView.click = function()
            {
                #print("i:", i)
                .currentPlaylistIndex = i
                #print("currentPlaylistIndex:", currentPlaylistIndex)
                #print("itemView.click parent:", ...)
                startCurrentPlaylist()
            }

            #shuffleButton = itemView.getView("shuffleButton")
            #button.create(shuffleButton, 0.55 * i)

            if(i % 2 == 0)
            {
                itemView.color = itemView.color * 0.5
                itemView.color.w = 0.1
            }

            scrollView.insertRow(playlistScrollView, itemView)
        }
    }
}

playlists = file.loadBinary(playlistsPath)
#print("playlists:", playlists)
loadPlaylists(playlists)