# warakiServer/code.tui
# this is run on the host, it handles get requests, as well as crawling for music

config = require(katipo.sitePath + "/config.tui")
siteInfo = require(katipo.sitePath + "/site.tui")
siteImage = file.loadData(katipo.sitePath + "/site.png")

musicDirectoryPath = config.musicDirectoryPath
doCrawlOnLaunch = config.doCrawlOnLaunch


clientSitePath = file.getAbsolutePath(katipo.sitePath + "/clientSite")
if(!file.fileExists(clientSitePath))
{
    error("missing publicData directory:", clientSitePath)
}

musicLibraryPath = clientSitePath + "/musicLibrary.tuib"
imagesDirectoryPath = clientSitePath + "/img"
clientScriptsDirectoryPath = clientSitePath + "/scripts"
clientFontsDirectoryPath = clientSitePath + "/fonts"

loadFilesFromDir = function(dirPath)
{
    files = {}
    contents = file.directoryContents(dirPath)
    for(fileName in contents)
    {
        if(string.subString(fileName, 0, 1) != ".")
        {
            fullPath = dirPath + "/" + fileName
            if(!file.isDirectory(fullPath))
            {
                fileData = file.loadData(fullPath)
                if(fileData)
                {
                    fileDataWrapper = {
                        fileName = fileName,
                        data = fileData
                    }
                    table.insert(files, fileDataWrapper)
                }
            }
        }
    }
    if(table.count(files) == 0)
    {
        return nil
    }
    return files
}


doCrawl = function()
{
    print("crawling library. This may take some time..")
    libraryCrawler = require(katipo.sitePath + "/libraryCrawler.tui")
    libraryCrawler.runCrawl(musicDirectoryPath)

    .availablePlaylists = libraryCrawler.availablePlaylists
    .songServerInfosBySongID = libraryCrawler.songServerInfosBySongID
    .directoryTree = libraryCrawler.directoryTree

    #print("availablePlaylists:", availablePlaylists) #tui bug, this should not be nil, but it is
    availablePlaylists = .availablePlaylists #hack to work around tui bug
    songServerInfosBySongID = .songServerInfosBySongID #hack to work around tui bug
    directoryTree = .directoryTree #hack to work around tui bug

    cacheData = {
        availablePlaylists = availablePlaylists,
        songServerInfosBySongID = songServerInfosBySongID,
        directoryTree = directoryTree
    }

    #print("cacheData:", cacheData)

    file.saveBinary(musicLibraryPath, cacheData)
}

cachedChecksum = false

checksumRecursively = function(path, fileName)
{
    if(file.isDirectory(path))
    {
        contents = file.directoryContents(path)
        foundResult = false
        for(fileOrDirectory in contents)
        {
            thisResult = checksumRecursively(path + "/" + fileOrDirectory, fileOrDirectory)
            if(thisResult)
            {
                if(foundResult)
                {
                    foundResult += thisResult
                }
                else
                {
                    foundResult = thisResult
                }
            }
        }
        return foundResult
    }
    else
    {
        if(fileName and string.subString(fileName, 0, 1) != ".")
        {
            return file.sha1(path)
        }
    }

    return nil
}

getChecksum = function(path)
{
    combinedChecksum = checksumRecursively(path)
    return string.sha1(combinedChecksum)
    /*if(cachedChecksum) #todo finish this (reset below in update loop), spamming / is a potential DOS attack vector for large sites otherwise
    {
        return cachedChecksum
    }
    .cachedChecksum = string.sha1(checksumRecursively(path, nil, "_"))
    cachedChecksum = .cachedChecksum
    return cachedChecksum*/
}

### this function is called when clients query this site
get = function(url, clientChecksum)
{
    print("in get. url:", url, " clientChecksum:", clientChecksum)
    urlSplit = string.split(url, "/")

    if(table.count(urlSplit) <= 1) #respond to get fileHost/
    {
        # if a clients simply enters "waraki" in the url, we end up here.
        # This is where we will load up and send all of the site's data in one big bundle
        # The following will probably be factored out in some way, but it is definitely a standard, the browser expects it like this
        # This checksums all of the client code, and clients check against it, like a version number. 
        # So clients will automatically download any updates to the site as an entire blob, but load from a cache otherwise
        
        checksum = getChecksum(clientSitePath)
        if(clientChecksum == checksum)
        {
            return {
                status = "ok"
                unchanged = true
            }
        }
        print("sending site data")

        files = {}
        musicLibraryWrapper = {
            fileName = "playlists.tuib"
            data = availablePlaylists
        }
        table.insert(files, musicLibraryWrapper)

        directoryTreeWrapper = {
            fileName = "directoryTree.tuib"
            data = directoryTree
        }
        table.insert(files, directoryTreeWrapper)

        #these could be cached, however this way, changes are immediate when the client reloads, without needing to restart the host process
        clientImageData = loadFilesFromDir(imagesDirectoryPath)
        clientScriptsData = loadFilesFromDir(clientScriptsDirectoryPath)
        clientFontsData = loadFilesFromDir(clientFontsDirectoryPath)
        
        clientSiteData = {
            images = clientImageData
            scripts = clientScriptsData
            fonts = clientFontsData
            files = files
            siteInfo = siteInfo
            siteImage = siteImage
            checksum = checksum
        }
        return {
            status = "ok"
            siteData = clientSiteData
        }
    }
    else if(urlSplit[0] == "songs") #waraki/songs/
    {
        songID = urlSplit[1]
        songInfo = songServerInfosBySongID[songID]
        if(songInfo and file.fileExists(songInfo.path))
        {
            print("file exists. sending...")
            return {
                status = "ok"
                songID = songID
                fileName = songInfo.fileName
                filePath = songInfo.path #internally, katipo looks for filePath and will replace this with the contents of the file. todo should probably just send the data here instead
            }
        }
        else
        {
            return {
                status = "error"
                message = "file not found"
            }
        }
    }

    return {
        status = "error"
        message = "unhandled request"
    }
}

runLoop = function()
{
    while(true)
    {
        sleep(1.0) #nothing to do yet
    }
}

if(!doCrawlOnLaunch and file.fileExists(musicLibraryPath))
{
    print("Loading cache...")
    cacheData = file.loadBinary(musicLibraryPath)

    .availablePlaylists = cacheData.availablePlaylists
    .songServerInfosBySongID = cacheData.songServerInfosBySongID
    .directoryTree = cacheData.directoryTree

    print("found ", table.count(availablePlaylists), " playlists")
}
else
{
    doCrawl()
}
